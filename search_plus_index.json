{"./":{"url":"./","title":"关于博客说明","keywords":"","body":"博客简介： 博客是博主多年的测试和运维工作的知识总结，主要涉及测试、运维等方面知识，也有cicd方面知识，以及多种工具和知识结合解决生产中遇到的问题；博主希望通过对自己掌握的知识进行汇总，展示出来，给需要的人提供帮助或者思路。若能帮助到大家，也就达到博主的目的。 如果大家是用手机浏览 本网站，点击左上角四个横岗，即可看到目录树，来查看所需的文章。 本人csdn博客地址：https://blog.csdn.net/qq_39919755 会不定期进行同步，毕竟csdn被百度抓取可能性较大，能帮助到更多利用搜索器寻找答案的人； 博客主要分为Linux、shell、Jenkins、docker、kubernetes（rancher）、NGINX、git、jmeter等几大类，绝大部分都是原创，甚至很多是博主亲身踩过的坑，借博客形式展示出来，在运维和测试人员遇到类似问题、场景提供解决思路或者灵感 "},"linux/tar-deal.html":{"url":"linux/tar-deal.html","title":"\"-\"在tar命令中的巧用","keywords":"","body":"\"-\"在tar命令中的巧用 首先来看示例： tar -cvf - /home | tar -xvf - 前面把压缩结果存到-，后面通过管道 | 把存到-中的文件解压，如果纯粹看这个，觉得这不瞎折腾么，下面从实战来说明使用它的好处 实战案例1： 海量小文件传输方法 接收机：nc -l 8888 | tar xzf - -C /dest-dir 发送机：tar czf - /source-dir/ | nc 接收机ip 8888 在 GNU 指令中，如果单独使用 - 符号，不加任何该加的文件名称时，代表\"标准输入/输出\"的意思,上面命令把结果输入到-,然后再解压-; 接收机可以带上参数v,如 xzvf（便于可视化）；如果发送机压缩命令带有z接收机也必须带上参数z 另外8888或其他端口，一定要放开，或者关闭防火墙；通过这种方式传递文件，相等于把先把文件压缩、然后通过scp 传输、再解压这几步合并成两步，并且省去了等待压缩和解压的时间。 实战案例2： find /directory -type f -name \"mypattern\" | tar -cf archive.tar -T - 找到匹配的文件后，直接压缩 实战案例3 docker cp 命令 docker cp命令中用法 ]# docker cp --help Usage: docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- ​ docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH 官网解释： Use ‘-‘ as the source to read a tar archive from stdin and extract it to a directory destination in a container. Use ‘-‘ as the destination to stream a tar archive of a container source to stdout. 所以我们可以 docker cp cfcc20077ad1:/opt/aa.tgz - | tar xvf - -C ./xx tar czf - anaconda-ks.cfg initial-setup-ks.cfg | docker cp - cfcc20077ad1:/opt/mydir tar成对使用，前面一个是stdin 后面一个是stdout , 最终文件不会改变，-里面存的是压缩包，传输完成后还是压缩包，如果是文件传输完成后还是文件 ，只不过tar 传输比较快 "},"docker/docker-install.html":{"url":"docker/docker-install.html","title":"docker 安装与优化","keywords":"","body":"Docker CE for CentOS 7.5/ubuntu19.04(centos7.5或以上版本) centos安装docker 安装yum⼯具 sudo yum install -y yum-utils 配置docker yum源 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo sudo yum makecache fast 查询可⽤版本 sudo yum list docker-ce --showduplicates | sort -r 安装指定版本docker-ce-17.03.2.ce,要先安装docker-ce-selinux-17.03.2.ce，否则安装docker-ce会报错 1 sudo yum -y install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-selinux-17.03.2.ce-1.el7.centos.noarch.rpm 2 sudo yum -y install docker-ce-17.03.2.ce-1.el7.centos 如果只下载安装包（和依赖库）： yum install -y docker-ce-17.03.2.ce --downloadonly --downloaddir=./ 安装最新版的docker sudo yum -y install docker-ce centos（Redhat）离线安装 只需要下载对应版本RPM包 即可； 阿里镜像源地址 如安装docker-18.09.5，下载对应的3个RPM包即可 containerd.io-1.2.5-3.1.el7.x86_64.rpm docker-ce-18.09.5-3.el7.x86_64.rpm docker-ce-cli-18.09.5-3.el7.x86_64.rpm 利用rancher提供的安装脚本在线安装docker 1，首先下载安装脚本 curl -OS https://releases.rancher.com/install-docker/18.09.sh 2，如果有连接外网VPN，可以使用 curl https://releases.rancher.com/install-docker/18.09.sh |sudo sh直接安装，但这个不建议 如果直接在线执行，缺点是无法修改脚本,失败率高，不建议,因为在centos安装时失败，并提示yum 源找不到可以通过修改一行代码，改用阿里的镜像源 centos|fedora|redhat|oraclelinux) #yum_repo=\"https://download.docker.com/linux/centos/docker-ce.repo\" yum_repo=\"https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\" 3, 下载脚本后第一件事就是修改为阿里的镜像源 下载脚本 阿里镜像源地址：https://mirrors.aliyun.com/docker-ce/linux/ 所以把 https://download.docker.com/linux 全部替换为： https://mirrors.aliyun.com/docker-ce/linux vi 或者vim 18.09.sh :%s/https:\\/\\/download.docker.com\\/linux/https:\\/\\/mirrors.aliyun.com\\/docker-ce\\/linux/g 然后执行sh 18.09.sh 安装成功的 Ubuntu安装docker Ubuntu执行rancher提供docker安装脚本 执行时报错： + sh -c apt-get install -y -q docker-ce= Reading package lists... Building dependency tree... Reading state information... E: Version '' for 'docker-ce' was not found 这个可能Ubuntu版本太高，需要手动来安装docker了 可以把下面命令执行完成后，再来执行rancher提供的docker安装脚本 sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common bash-completion # step 2: 安装GPG证书 sudo curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - # Step 3: 写入软件源信息 sudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" # Step 4: 更新并安装 Docker-CE sudo apt-get -y update ubuntu在线安装 sudo apt install docker.io 或sudo apt install docker-ce ubuntu离线安装 离线安装包 还在找 rancher提供的docker安装脚本的GitHub：https://github.com/rancher/install-docker 改变docker的image存放⽬录（下面提供三种方式）、配置加速器等 修改配置文件，配置加速器 中写入如下内容（如果文件不存在请新建该文件） [root@yktapp1 dockersh]# cat /etc/docker/daemon.json { \"registry-mirrors\": [ \"https://registry.docker-cn.com\" ] } 也可以使用阿里的镜像加速器和本地仓库配置 #### 使用内部仓库地址的配置 [root@yktapp1 dockersh]# cat /etc/docker/daemon.json { \"registry-mirrors\": [\"https://registry.docker-cn.com\"], \"insecure-registries\": [\"0.0.0.0/0\"] } \"insecure-registries\": [\"0.0.0.0/0\"] 通配表示所有http协议仓库，如果只想通配某个http协议仓库，可以写成具体名称或者通配 \"insecure-registries\":[\"10.251.66.44:5000\"] \"insecure-registries\":[\"10.251.26.0/24\"] - 参考harbor GitHub文档说明 If this private registry supports only HTTP or HTTPS with an unknown CA certificate, please add --insecure-registry myregistrydomain.com to the daemon's start up arguments. In the case of HTTPS, if you have access to the registry's CA certificate, simply place the CA certificate at /etc/docker/certs.d/myregistrydomain.com/ca.crt . 自签名https和不安全http都可以用这种方式解决，自签名的证书，也可以把证书copy到相应目录解决，无需添加insecure-registries选项，具体方法参见harbor的使用说明 - 注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。 ##### 1），指定docker存储位置，方法1（指定了overlay2，这种方式比overlay更高效，kernel较高的Linux默认就是这种） cat > /etc/docker/daemon.json https://wgaccbzr.mirror.aliyuncs.com\"], \"data-root\": \"/app/lib/docker\" } { \"storage-driver\": \"overlay2\", \"storage-opts\":[\"overlay2.override_kernel_check=true\"] } EOF #### 2），把指定的盘符挂载给docker 直接修改/etc/fstab中把一个逻辑卷挂到docker存储目录 /var/lib/docker中，但要确保原有的挂载没有东西，并取消之前的挂载关系， umout -a oldpath；可以通过下面查看原有的挂载和逻辑卷情况 [root@localhost ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT fd0 2:0 1 4K 0 disk sda 8:0 0 100G 0 disk ├─sda1 8:1 0 1G 0 part /boot └─sda2 8:2 0 99G 0 part ├─centos-root 253:0 0 50G 0 lvm / ├─centos-swap 253:1 0 7.9G 0 lvm [SWAP] └─centos-home 253:2 0 41.1G 0 lvm /home #### 3），软链的方式 （不推荐，作为挽救使用） systemctl stop docker mv /var/lib/docker /home/docker ln -s /home/docker /var/lib/docker systemctl start docker ### 安装 docker-compose wget -c https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s-uname -m` cp docker-compose-Linux-x86_64 /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose - 之后重新启动服务。 sudo systemctl daemon-reload sudo systemctl start docker sudo systemctl enable docker - 注意最好配置完成好了 再启动docker，避免启动docker产生文件存储在默认的路径 ### 测试安装是否成功 docker ps ### 非root用户操作docker sudo gpasswd -a your-user docker or sudo usermod -aG docker your-user 这两种方式 都是把非root用户添加到docker组 ## Kernel性能调优 cat >> /etc/sysctl.conf "},"k8s/kubectl-user-instruction.html":{"url":"k8s/kubectl-user-instruction.html","title":"kubectl常用命令汇总（以及curl注入）","keywords":"","body":"kubectl 详细命令用法可以参考官网： https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands kubectl 常用的命令总结 只显示默认命名空间的pods kubectl get pods 显示所有空间的pod kubectl get pods --all-namespaces 显示指定空间的pod kubectl get pods -o wide --namespace apm 其中--namespace 与-n 作用等同，后面接命名空间参数 kubectl get deployment -n apm kubectl get pods,svc,rc -n apm svc和services是一样的 这些命令都可以通过 kubectl get --help 来查看帮助 删除 只能删除默认命名空间的deployment kubectl delete deployment nginx 删除指定空间的deployment/其他资源等 kubectl delete TYPE RESOURCE -n NAMESPACE 具体如下： kubectl delete deployment shop-app -n test-shop kubectl delete TYPE --all -n NAMESPACE kubectl delete all -n NAMESPACE kubectl delete all --all 使用yaml文件创建pod kubectl apply -f apptrace-receiver-deployment.yaml apply 和 create 命令都可以后跟yaml，创建所需资源,初次创建pod时可以互相替换使用；如果已有pod只是用于更新的话，又可以和replace相互替换使用；本着化繁就简的原则，create和replace都使用apply; 而且apply属于申明式语法，这个更加灵活，多次执行不会报错，只会更新改变的部分；像Jenkinsfile也已经从脚本语法向申明式转变。 使用kubectl命令把pod、卷、各种资源导出为yaml格式： kubectl get pods podA -n NAMEAPSCE-A -o yaml --export> padA.yaml pod 可以换成其他申明式资源如卷、services等；如果不带上--export 生成文件会有很多无用的内容 现在很多产品如rancher openshift，等；UI界面 直接可视化操作导出各种资源，掌握命令很多时候，可以事半功倍。-o更详细用法 下面有单独说明。 查看命名空间apm的collector服务详情 ```kubectl describe service/apptrace-collector --namespace apm --namespace 和-n 作用相同 ### 查看pod日志 ```kubectl logs podname --namespace apm (可以带上 -f 参数) 为节点机apm-docker001打标签 zookeeper-node=apm-docker001,查看标签等； 为节点机打标签和查看 kubectl label nodes apm-docker001 zookeeper-node=apm-docker001 kubectl get nodes --show-labels 为命名空间打标签和查看 kubectl label namespace $your-namesapce istio-injection=enabled kubectl get namespaces --show-labels 给名为foo的Pod添加label unhealthy=true kubectl label pods foo unhealthy=true 查看某种类型字段下有哪些参数； kubectl explain pods kubectl explain Deployment kubectl explain Deployment.spec kubectl explain Deployment.spec.spec kubectl explain Deployment.spec.template kubectl explain Deployment.spec.template.spec 如查看Deployment.spec.template 可以有哪些参数 [root@k8s-master ~]# kubectl explain Deployment.spec.template KIND: Deployment VERSION: extensions/v1beta1 RESOURCE: template DESCRIPTION: Template describes the pods that will be created. PodTemplateSpec describes the data a pod should have when created from a template FIELDS: metadata Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata spec Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status 在pod内部，执行shell命令 kubectl exec podname printenv | ps aux | cat、ls 某个文件（如果pod不在默认空间，用-n 指定相应空间） 如：kubectl exec app-demo-68b4bd9759-sfpcf -n test-shop printenv 或者在kubectl exec podname -- 再跟shell命令 如： kubectl exec -it spark-master-xksl -c spark-master -n spark -- mkdir -p /usr/local/spark shell命令前，要加-- 号，不然shell命令中的参数，不能识别 kubectl exec 后面只能是pod,目前还不支持deployment daemonnset等 巧用kubectl 帮助文件 如你只记得部分命令 get ,可以用 kubectl get --help 同理 kubectl create rolebinding 不知道后面接什么 也可以--help一下,记得关键字越多 带上后再使用help，如果只记得部分 就先help 如 kubectl create --help 这样create 所有类型的应用怎么创建 都有了 同样也可以直接 kubectl --help 这样kubectl 有哪些用法就显示出来， 我们要一级级的利用帮助 可能刚开始记住前面一个关键字，写完关键字 help一下 又有很多详细的用法 Kubernetes 部署失败的 10 个最普遍原因 详细说明链接：http://dockone.io/article/2247；注意一定勤看日志 ** kubectl describe pod kube-state-metrics-xntdx-978bb474d-8x7pg -n efk-jpvgs** ** 查看event部分：** Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal Scheduled 3m default-scheduler Successfully assigned efk-jpvgs/kube-state-metrics-xntdx-978bb474d-8x7pg to szly-manager Normal Pulling 1m (x4 over 3m) kubelet, szly-manager pulling image \"k8s.gcr.io/kube-state-metrics:v1.5.0\" Warning Failed 1m (x4 over 3m) kubelet, szly-manager Failed to pull image \"k8s.gcr.io/kube-state-metrics:v1.5.0\": rpc error: code = Unknown desc = Error response from daemon: Get https://k8s.gcr.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) Warning Failed 1m (x4 over 3m) kubelet, szly-manager Error: ErrImagePull Warning Failed 1m (x6 over 3m) kubelet, szly-manager Error: ImagePullBackOff Normal BackOff 52s (x7 over 3m) kubelet, szly-manager Back-off pulling image \"k8s.gcr.io/kube-state-metrics:v1.5.0\" 这个就说明了问题 镜像拉取失败 ，记住遇到问题 一定要先看日志，要不然像无头苍蝇，瞎修改 如果已经启动成了的 容器（pod） 可以通过命令： kubectl logs efk-jpvgs-elasticsearch-0 -n efk-jpvgs 来查看，或者直接在rancher里面选择pod后view logs ,查看 events 区域的提示内容 查看etcd 健康状态 kubectl get componentstatuses 或者kubectl get cs NAME STATUS MESSAGE ERROR controller-manager Healthy ok etcd-1 Unhealthy Get https://172.16.31.16:2379/health: dial tcp 172.16.31.16:2379: connect: connection refused scheduler Healthy ok etcd-2 Healthy {\"health\": \"true\"} etcd-0 Healthy {\"health\": \"true\"} 更详细的排错方案见： https://kubernetes.feisky.xyz/pai-cuo-zhi-nan/pod kubectl 与 Docker 命令关系 可以参考： http://docs.kubernetes.org.cn/70.html 特别说明 docker run redis --requirepass,RedisP@ssw0rd 像这种 run 镜像后面的参数，则可以在docker-compose或者k8s的cmd或者入口处定义，无需二次制作镜像 也参考官网镜像的dockerfile，如dockerfile最后的一句话是CMD [\"redis-server\"]，我们 部署时，在rancher UI命令(CMD) redis-server --requirepass 自己的密码 填写完成后启动redis，并测试密码是否生效； 如果没有找到镜像的dockerfile，当run镜像后，指定了工作路径，路径里面一般会有个可执行的二进制文件，一般可以在入口命令中，设置执行二进制文件，后面跟参数 ；./xx -args args_value 但这个需要灵活应变； kubectl 命令规律总结 先看一组命令 kubectl delete sa metricbeat -n efk kubectl get sa --all-namespaces kubectl delete daemon-set metricbeat -n efk 1.会发现，kubectl 不管get 、delete describe等操作 后面跟资源类型 如果sa(serviceaccout) deployment pod,然后是资源名称，如果没有资源名称，则删除、获取此类型所有的资源；最后限定某个命名空间，或者全部命名空间；这个限定命名空间 可以放在kubectl 后面，也可以放在所有参数后面 -o 是指定输出格式 输出格式 说明 -o=custom-columns= 根据自定义列名进行输出，以逗号分隔 -o=custom-colimns-file= 从文件中获取自定义列名进行输出 -o=json 以JSON格式显示结果 -o=jsonpath= 输出jsonpath表达式定义的字段信息 -o=jsonpath-file= 输出jsonpath表达式定义的字段信息，来源于文件 -o=name 仅输出资源对象的名称 -o=wide 输出额外信息。对于Pod，将输出Pod所在的Node名 -o=yaml 以yaml格式显示结果 如下： kubectl get sa -n efk -o yaml kubectl get sa efk-elaticsearch -n efk -o yaml >xxx.yaml kubectl get pod efk-elaticsearch-0 -n efk -o wide 更多用法可以参照官网或者国内翻译的博客 https://blog.csdn.net/xingwangc2014/article/details/51204224 因为k8s 采用的是REST API接口，所有命令都最终会转换成curl -X PUT POS等形式,为什么不直接使用curl命令，因为需要一堆相关授权，rancher UI里面 在deploy或其他资源中，选择api查看 就可以查到，也可以点击右侧的edit编辑后 通过curl命令提交 API Request cURL command line: curl -u \"${CATTLE_ACCESS_KEY}:${CATTLE_SECRET_KEY}\" \\ -X PUT \\ -H 'Accept: application/json' \\ -H 'Content-Type: application/json' \\ -d '{\"annotations\":{\"cattle.io/timestamp\":\"\", \"cni.projectcalico.org/podIP\":\"10.42.1.44/32\"}, \"containers\":[{\"allowPrivilegeEscalation\":false, \"exitCode\":null, \"image\":\"172.16.35.31:1180/apm-images/gettoken:1.0\", \"imagePullPolicy\":\"IfNotPresent\", \"initContainer\":false, \"name\":\"genttoken\", \"ports\":[{\"containerPort\":8001, \"dnsName\":\"genttoken-nodeport\", \"kind\":\"NodePort\", \"name\":\"8001tcp301001\", \"protocol\":\"TCP\", \"sourcePort\":30100, \"type\":\"/v3/project/schemas/containerPort\"}], \"privileged\":false, \"procMount\":\"Default\", \"readOnly\":false, \"resources\":{\"type\":\"/v3/project/schemas/resourceRequirements\"}, \"restartCount\":0, \"runAsNonRoot\":false, \"state\":\"running\", \"stdin\":true, \"stdinOnce\":false, \"terminationMessagePath\":\"/dev/termination-log\", \"terminationMessagePolicy\":\" 等等 修改完成后 可以点击send request来提交 "},"jenkins/jenkins-slave-for-docker.html":{"url":"jenkins/jenkins-slave-for-docker.html","title":"Jenkins调用docker编译程序","keywords":"","body":"如果用docker 容器编译程序 有两种方案可供选择 1，激活镜像作为slave编译 采用Jenkins提供的jnlp-slave 或ssh-slave 标准镜像二次封装，或者初始镜像，然后通过label 选择镜像后进行编译； 这种编译的原理是：Jenkins通过标签选择相关docker镜像，并激活成容器，把此容器当做slave（节点机）使用； ​ Jenkins提供的镜像地址：https://hub.docker.com/u/jenkinsci ​ jnlp-slave 和ssh-slave 镜像都能激活作为slave节点使用，区别是采用不同协议连接到容器内部：ssh和jnlp； 使用这种方式需要额外在Jenkins里面配置，插件里面安装docker插件，然后配置Docker Host URL,来找到可以使用的docker，如果Jenkins和docker在同一台服务器可以直接填写为：unix:///var/run/docker.sock ，如果不在同一台机器要填写docker所在的机器ip：tcp://ip:2375，并且要在docker所在机器的 /etc/docker/daemon.json 里面添加2375端口 \"hosts\": [ ​ \"tcp://0.0.0.0:2375\", ​ \"unix:///var/run/docker.sock\" ​ ] 具体怎么调用这里不作为重点，这里重点说明的方案的选择，可以参考 https://blog.csdn.net/qq_31977125/article/details/82999872 这位博主有详细的操作步骤 下面是重点说明编译方式 2，直接docker run编译 把源码下载到宿主机，通过-v 挂载到容器中，然后指定入口命令编译此目录，编译完成后 销毁容器 docker run --rm -v `pwd`:/mypro -w /mypro nodeshift/centos7-s2i-nodejs:10.16.0 /bin/bash -c \"npm install\" docker run --rm -v `pwd`:/opt/mypro -w /opt/mypro goenv-centos:test7 /bin/bash -c \"GOPROXY=https://goproxy.io /usr/local/go/bin/go build\" 上面两个是例子，goenv-centos:test7是自制作的镜像 注意：提前制作好镜像，镜像里面把各种编译依赖放进去，制作镜像有两种方式 ​ 激活一个基础镜像，编译下载各种依赖库，能正式编译后，commit容器为镜像，这种方式不推荐 ​ 建议把操作步骤整理起来 编写到dockerfile中 实战案例 基于centos7.6 镜像制作出可以编译go/rust程序的镜像（生产中最好一个镜像只编译一种语言程序，并且是基于此语言的镜像） Dockerfile FROM centos:7.6.1810 WORKDIR /opt ADD https://github.com/facebook/zstd/releases/download/v1.4.0/zstd-1.4.0.tar.gz ./ ADD https://github.com/edenhill/librdkafka/archive/master.zip ./ ADD https://studygolang.com/dl/golang/go1.12.5.linux-amd64.tar.gz ./ COPY expect.sh ./ RUN mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.bak && \\ curl -s http://mirrors.aliyun.com/repo/Centos-7.repo -o /etc/yum.repos.d/CentOS-Base.repo && \\ curl -s http://mirrors.aliyun.com/repo/epel-7.repo -o /etc/yum.repos.d/epel-7.repo && \\ yum repolist && \\ yum -y install wget make expect gcc gcc-c++ unzip openssl-devel clang-devel libpcap-devel perl.x86_64 \\ which.x86_64 git && \\ curl -sSf https://sh.rustup.rs -o rustup.sh && chmod a+x rustup.sh && \\ chmod a+x expect.sh && /bin/bash ./expect.sh && \\ source $HOME/.cargo/env && \\ tar xzf zstd-1.4.0.tar.gz && \\ tar xzf go1.12.5.linux-amd64.tar.gz -C /usr/local && \\ unzip master.zip && \\ cd zstd-1.4.0 && CFLAGS=\"-O3 -fPIC\" make install && \\ cd ../librdkafka-master && ./configure --prefix=/usr && make && make install && \\ cp -rf /usr/lib/librdkafka* /usr/lib/pkgconfig /usr/lib64 && \\ chmod a+x -R /usr/local/go && \\ echo -e 'export GOPROXY=https://goproxy.io' >> /etc/profile && \\ echo -e 'export GOROOT=/usr/local/go' >> /etc/profile && \\ echo -e 'export GOPATH=/opt/mypro' >> /etc/profile && \\ echo -e 'export export PATH=$GOROOT/bin:/root/.cargo/bin:$PATH' >> /etc/profile && \\ echo -e 'export LIBRARY_PATH=$LIBRARY_PATH:/usr/lib64/llvm' >> /etc/profile && \\ echo -e 'export LD_LIBRARY_PATH=/usr/local/lib/:${LD_LIBRARY_PATH}' >> /etc/profile && \\ source /etc/profile && \\ yum clean all && \\ rm -rf /opt/* && \\ mkdir -p /opt/mypro COPY ustc-config /root/.cargo/config ustc-config [source.crates-io] registry = \"https://github.com/rust-lang/crates.io-index\" replace-with = 'ustc' [source.ustc] registry = \"git://mirrors.ustc.edu.cn/crates.io-index\" expect.sh #!/usr/bash expect 把Dockerfile，和expect.sh、ustc-config放在同一目录，然后在此目录执行build命令： docker build -t 172.16.35.31:1180/apm-images/centos7-goenv:1:1 . go程序编译： docker run --rm -v `pwd`:/opt/mypro -w /opt/mypro 172.16.35.31:1180/apm-images/centos7-goenv:1 /bin/bash -c \"GOPROXY=https://goproxy.io /usr/local/go/bin/go build\" rust程序编译 docker run --rm -v `pwd`:/opt/mypro -w /opt/mypro 172.16.35.31:1180/apm-images/centos7-goenv:1 /bin/bash -c \"/root/.cargo/bin/cargo build --release\" 这种方式编译最大优点，不管是开发、运维还是测试都无需搭建编译环境（有时候搭建一套编译环境是费时费力的事情，而且移植性差），直接从docker仓库拉取此镜像后就能编译； "}}